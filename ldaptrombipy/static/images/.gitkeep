alter table gn_synthese.synthese 
drop column id_nomenclature_obs_technique 

insert into gn_synthese.synthese (
date_min,
date_max,
count_min,
count_max,
the_geom_4326 ,
the_geom_local ,
cd_nom ,
nom_cite
)
SELECT
'25/11/2020',
'25/11/2020',
1,
2,
ST_SetSRID(ST_GeomFromText('POINT(3.50 44.50)'), 4326),
st_transform(ST_SetSRID(ST_GeomFromText('POINT(3.50 44.50)'), 4326),2154),
240,
'truc'
from pg_catalog.generate_series(0,100000) 

-- Avec trigger
-- 1000 : 1.76s
-- 10 000: 16s

  CREATE OR REPLACE FUNCTION gn_synthese.fct_tri_cal_sensi_diff_level_on_each_row() RETURNS TRIGGER
  LANGUAGE plpgsql
  AS $$ 
  -- Calculate sensitivity and diffusion level on update in synthese
  DECLARE calculated_id_sensi integer;
    BEGIN
        SELECT 
        gn_sensitivity.get_id_nomenclature_sensitivity(
          NEW.date_min::date, 
          taxonomie.find_cdref(NEW.cd_nom), 
          NEW.the_geom_local,
          ('{"STATUT_BIO": ' || NEW.id_nomenclature_bio_status::text || '}')::jsonb
        ) INTO calculated_id_sensi;
      UPDATE gn_synthese.synthese 
      SET 
      id_nomenclature_sensitivity = calculated_id_sensi,
      -- TODO: est-ce qu'on remet à jour le niveau de diffusion lors d'une MAJ de la sensi ?
      id_nomenclature_diffusion_level = (
        SELECT ref_nomenclatures.get_id_nomenclature(
            'NIV_PRECIS',
            gn_sensitivity.calculate_cd_diffusion_level(
              ref_nomenclatures.get_cd_nomenclature(OLD.id_nomenclature_diffusion_level),
              ref_nomenclatures.get_cd_nomenclature(calculated_id_sensi)
          )
      	)
      )
      WHERE id_synthese = OLD.id_synthese
      ;
      RETURN NULL;
    END;
  $$; 
 
 
 CREATE TRIGGER tri_update_calculate_sensitivity
 AFTER UPDATE OF date_min, date_max, cd_nom, the_geom_local, id_nomenclature_bio_status ON gn_synthese.synthese
  FOR EACH ROW
  EXECUTE PROCEDURE gn_synthese.fct_tri_cal_sensi_diff_level_on_each_row();


SELECT 
tsr.cd_nom,
 gn_sensitivity.get_id_nomenclature_sensitivity(
         '25/11/2020', 
          taxonomie.find_cdref(tsr.cd_nom ), 
          st_transform(ST_SetSRID(ST_GeomFromText('POINT(3.50 44.50)'), 4326),2154),
          ('{"STATUT_BIO": ' || (select gn_synthese.get_default_nomenclature_value('STATUT_BIO')) || '}')::jsonb
        ) 
FROM gn_sensitivity.t_sensitivity_rules tsr 
order by  gn_sensitivity.get_id_nomenclature_sensitivity(
         '25/11/2020', 
          taxonomie.find_cdref(tsr.cd_nom ), 
          st_transform(ST_SetSRID(ST_GeomFromText('POINT(3.50 44.50)'), 4326),2154),
          ('{"STATUT_BIO": ' || (select gn_synthese.get_default_nomenclature_value('STATUT_BIO')) || '}')::jsonb
        ) desc

 CREATE OR REPLACE FUNCTION gn_synthese.fct_tri_cal_sensi_diff_level_on_each_row() RETURNS TRIGGER
  LANGUAGE plpgsql
  AS $$ 
  -- Calculate sensitivity and diffusion level on update in synthese
    BEGIN
      UPDATE gn_synthese.synthese 
      SET id_nomenclature_diffusion_level = (
        SELECT ref_nomenclatures.get_id_nomenclature(
            'NIV_PRECIS',
            gn_sensitivity.calculate_cd_diffusion_level(
              ref_nomenclatures.get_cd_nomenclature(OLD.id_nomenclature_diffusion_level),
              ref_nomenclatures.get_cd_nomenclature(OLD.id_nomenclature_sensitivity)
          )
      	)
      )
      WHERE id_synthese = OLD.id_synthese
      ;
      RETURN NULL;
    END;
  $$;  


        DROP TRIGGER tri_update_calculate_sensitivity ON gn_synthese.synthese;
          DROP TRIGGER tri_insert_calculate_sensitivity ON gn_synthese.synthese;

       
 CREATE TRIGGER tri_insert_calculate_sensitivity
 AFTER INSERT ON gn_synthese.synthese
  REFERENCING NEW TABLE AS NEW
  FOR EACH STATEMENT
  EXECUTE PROCEDURE gn_synthese.fct_tri_cal_sensi_diff_level_on_each_statement();
       
CREATE TRIGGER tri_update_calculate_sensitivity
 AFTER UPDATE OF id_nomenclature_sensitivity ON gn_synthese.synthese
  FOR EACH ROW
  EXECUTE PROCEDURE gn_synthese.fct_tri_cal_sensi_diff_level_on_each_row();
        
 CREATE OR REPLACE FUNCTION gn_synthese.fct_tri_cal_sensi_diff_level_on_each_row() RETURNS TRIGGER
  LANGUAGE plpgsql
  AS $$ 
  -- Calculate sensitivity and diffusion level on update in synthese
    BEGIN
      UPDATE gn_synthese.synthese 
      SET id_nomenclature_diffusion_level = (
        SELECT ref_nomenclatures.get_id_nomenclature(
            'NIV_PRECIS',
            gn_sensitivity.calculate_cd_diffusion_level(
              ref_nomenclatures.get_cd_nomenclature(NEW.id_nomenclature_diffusion_level),
              ref_nomenclatures.get_cd_nomenclature(NEW.id_nomenclature_sensitivity)
          )
      	)
      )
      WHERE NEW.id_synthese = OLD.id_synthese
      ;
      RETURN NULL;
    END;
  $$;  
 
 
 
 
 
 
CREATE OR REPLACE FUNCTION gn_sensitivity.calculate_cd_diffusion_level(
  cd_nomenclature_diffusion_level character varying, cd_nomenclature_sensitivity character varying
)
 RETURNS character varying
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF cd_nomenclature_diffusion_level IS NULL 
    THEN 
    
    RETURN
    CASE 
      WHEN cd_nomenclature_sensitivity = '0' THEN '5'
      WHEN cd_nomenclature_sensitivity = '1' THEN '3'
      WHEN cd_nomenclature_sensitivity = '2' THEN '2'
      WHEN cd_nomenclature_sensitivity = '3' THEN '3'
      WHEN cd_nomenclature_sensitivity = '4' THEN '4'
    END;
  ELSE 
    insert into logs(messages) VALUES (cd_nomenclature_diffusion_level);
    RETURN cd_nomenclature_diffusion_level;
  END IF;
END;
$function$









alter table gn_synthese.synthese 
drop column id_nomenclature_obs_technique 

delete from logs;

insert into gn_synthese.synthese (
date_min,
date_max,
count_min,
count_max,
the_geom_4326 ,
the_geom_local ,
cd_nom ,
nom_cite
)
SELECT
'25/11/2020',
'25/11/2020',
1,
2,
ST_SetSRID(ST_GeomFromText('POINT(3.50 44.50)'), 4326),
st_transform(ST_SetSRID(ST_GeomFromText('POINT(3.50 44.50)'), 4326),2154),
240,
'truc'
from pg_catalog.generate_series(0,10000) 


delete from gn_synthese.cor_area_synthese 

-- sans trigger
-- 1000: 541ms
-- 10 000: 4s
-- 100 000: 47s

-- Avec trigger sensi on each statement
-- 1000 : 1.76s
-- 10 000: 16s
-- 100 000 2m 49


-- trigger area on each row initial (st_touches sur toutes les geom)
-- 1000: 2s
-- 10 000: 22s
-- 100 000: 3m34s

--trigger area on each statement (st_touches sur toutes les geom)
--- 1000: 2s
--- 10 000: 20s
-- 100 000: 3m30

-- triger area on each statement optimisé (st_touches seulement sur les geom non ponctuelles)
-- 1000: 826ms
-- 10 000: 9s
-- 100 000: 1m11s




select count(*)
from ref_geo.l_areas la 
where la."enable" is TRUE
  

CREATE OR REPLACE FUNCTION gn_synthese.fct_trig_insert_in_cor_area_synthese()
  RETURNS trigger AS
$BODY$
  DECLARE
  geom_change boolean;
  BEGIN
  geom_change = false;
  IF(TG_OP = 'UPDATE') THEN
	  SELECT INTO geom_change NOT public.ST_EQUALS(OLD.the_geom_local, NEW.the_geom_local);
  END IF;

  IF (geom_change) THEN
	  DELETE FROM gn_synthese.cor_area_synthese 
    USING NEW as updated_rows
    WHERE id_synthese = updated_rows.id_synthese;
  END IF;

  -- Intersection avec toutes les areas et écriture dans cor_area_synthese
    IF (TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND geom_change )) THEN
      INSERT INTO gn_synthese.cor_area_synthese 
        SELECT
          updated_rows.id_synthese AS id_synthese,
          a.id_area AS id_area
        FROM NEW as updated_rows
        JOIN ref_geo.l_areas a
            ON public.ST_INTERSECTS(updated_rows.the_geom_local, a.geom)  AND NOT public.ST_TOUCHES(updated_rows.the_geom_local,a.geom)
        WHERE a.enable IS true;
    END IF;
  RETURN NULL;
  END;
  $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
 
 
       INSERT INTO gn_synthese.cor_area_synthese 
        SELECT
          updated_rows.id_synthese AS id_synthese,
          a.id_area AS id_area
        FROM gn_synthese.synthese as updated_rows
        JOIN ref_geo.l_areas a
            ON public.ST_INTERSECTS(updated_rows.the_geom_local, a.geom)  AND NOT public.ST_TOUCHES(updated_rows.the_geom_local,a.geom)
        WHERE a.enable IS true
       limit 10
        ;


 
 CREATE TRIGGER tri_update_calculate_sensitivity
 AFTER UPDATE OF date_min, date_max, cd_nom, the_geom_local, id_nomenclature_bio_status ON gn_synthese.synthese
  FOR EACH ROW
  EXECUTE PROCEDURE gn_synthese.fct_tri_cal_sensi_diff_level_on_each_row();


SELECT 
tsr.cd_nom,
 gn_sensitivity.get_id_nomenclature_sensitivity(
         '25/11/2020', 
          taxonomie.find_cdref(tsr.cd_nom ), 
          st_transform(ST_SetSRID(ST_GeomFromText('POINT(3.50 44.50)'), 4326),2154),
          ('{"STATUT_BIO": ' || (select gn_synthese.get_default_nomenclature_value('STATUT_BIO')) || '}')::jsonb
        ) 
FROM gn_sensitivity.t_sensitivity_rules tsr 
order by  gn_sensitivity.get_id_nomenclature_sensitivity(
         '25/11/2020', 
          taxonomie.find_cdref(tsr.cd_nom ), 
          st_transform(ST_SetSRID(ST_GeomFromText('POINT(3.50 44.50)'), 4326),2154),
          ('{"STATUT_BIO": ' || (select gn_synthese.get_default_nomenclature_value('STATUT_BIO')) || '}')::jsonb
        ) desc

 CREATE OR REPLACE FUNCTION gn_synthese.fct_tri_cal_sensi_diff_level_on_each_row() RETURNS TRIGGER
  LANGUAGE plpgsql
  AS $$ 
  -- Calculate sensitivity and diffusion level on update in synthese
    BEGIN
      UPDATE gn_synthese.synthese 
      SET id_nomenclature_diffusion_level = (
        SELECT ref_nomenclatures.get_id_nomenclature(
            'NIV_PRECIS',
            gn_sensitivity.calculate_cd_diffusion_level(
              ref_nomenclatures.get_cd_nomenclature(OLD.id_nomenclature_diffusion_level),
              ref_nomenclatures.get_cd_nomenclature(OLD.id_nomenclature_sensitivity)
          )
      	)
      )
      WHERE id_synthese = OLD.id_synthese
      ;
      RETURN NULL;
    END;
  $$;  


        DROP TRIGGER tri_update_calculate_sensitivity ON gn_synthese.synthese;
          DROP TRIGGER tri_insert_calculate_sensitivity ON gn_synthese.synthese;

       
 CREATE TRIGGER tri_insert_calculate_sensitivity
 AFTER INSERT ON gn_synthese.synthese
  REFERENCING NEW TABLE AS NEW
  FOR EACH STATEMENT
  EXECUTE PROCEDURE gn_synthese.fct_tri_cal_sensi_diff_level_on_each_statement();
       
CREATE TRIGGER tri_update_calculate_sensitivity
 AFTER UPDATE OF id_nomenclature_sensitivity ON gn_synthese.synthese
  FOR EACH ROW
  EXECUTE PROCEDURE gn_synthese.fct_tri_cal_sensi_diff_level_on_each_row();
        
 CREATE OR REPLACE FUNCTION gn_synthese.fct_tri_cal_sensi_diff_level_on_each_row() RETURNS TRIGGER
  LANGUAGE plpgsql
  AS $$ 
  -- Calculate sensitivity and diffusion level on update in synthese
    BEGIN
      UPDATE gn_synthese.synthese 
      SET id_nomenclature_diffusion_level = (
        SELECT ref_nomenclatures.get_id_nomenclature(
            'NIV_PRECIS',
            gn_sensitivity.calculate_cd_diffusion_level(
              ref_nomenclatures.get_cd_nomenclature(NEW.id_nomenclature_diffusion_level),
              ref_nomenclatures.get_cd_nomenclature(NEW.id_nomenclature_sensitivity)
          )
      	)
      )
      WHERE NEW.id_synthese = OLD.id_synthese
      ;
      RETURN NULL;
    END;
  $$;  
 
 
 
 
 
 
CREATE OR REPLACE FUNCTION gn_sensitivity.calculate_cd_diffusion_level(
  cd_nomenclature_diffusion_level character varying, cd_nomenclature_sensitivity character varying
)
 RETURNS character varying
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF cd_nomenclature_diffusion_level IS NULL 
    THEN 
    
    RETURN
    CASE 
      WHEN cd_nomenclature_sensitivity = '0' THEN '5'
      WHEN cd_nomenclature_sensitivity = '1' THEN '3'
      WHEN cd_nomenclature_sensitivity = '2' THEN '2'
      WHEN cd_nomenclature_sensitivity = '3' THEN '3'
      WHEN cd_nomenclature_sensitivity = '4' THEN '4'
    END;
  ELSE 
    insert into logs(messages) VALUES (cd_nomenclature_diffusion_level);
    RETURN cd_nomenclature_diffusion_level;
  END IF;
END;
$function$




CREATE OR REPLACE FUNCTION gn_synthese.fct_trig_insert_in_cor_area_synthese()
  RETURNS trigger AS
$BODY$
  DECLARE
  geom_change boolean;
  BEGIN
  geom_change = false;
  IF(TG_OP = 'UPDATE') THEN
	  SELECT INTO geom_change NOT public.ST_EQUALS(OLD.the_geom_local, NEW.the_geom_local);
  END IF;

  IF (geom_change) THEN
	  DELETE FROM gn_synthese.cor_area_synthese 
    USING NEW as updated_rows
    WHERE id_synthese = updated_rows.id_synthese;
  END IF;

  -- Intersection avec toutes les areas et écriture dans cor_area_synthese
    IF (TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND geom_change )) THEN
      INSERT INTO gn_synthese.cor_area_synthese 
        SELECT
          updated_rows.id_synthese AS id_synthese,
          a.id_area AS id_area
        FROM ref_geo.l_areas a
        JOIN NEW as updated_rows
            ON public.ST_INTERSECTS(updated_rows.the_geom_local, a.geom)  AND NOT public.ST_TOUCHES(updated_rows.the_geom_local,a.geom)
        WHERE a.enable IS true;
    END IF;
  RETURN NULL;
  END;
  $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

 
 drop trigger tri_insert_cor_area_synthese on gn_synthese.synthese;
 CREATE TRIGGER tri_insert_cor_area_synthese
  AFTER insert ON gn_synthese.synthese
  REFERENCING NEW TABLE AS NEW
  FOR EACH STATEMENT
  
  EXECUTE PROCEDURE gn_synthese.fct_trig_insert_in_cor_area_synthese();

-- REQUETE ACTUELLE
explain analyze 
SELECT
updated_rows.id_synthese AS id_synthese,
a.id_area AS id_area
FROM gn_synthese.synthese as updated_rows
JOIN ref_geo.l_areas a
ON public.ST_INTERSECTS(updated_rows.the_geom_local, a.geom)  OR NOT public.ST_TOUCHES(updated_rows.the_geom_local,a.geom)
WHERE a.enable IS TRUE;

Gather  (cost=1000.00..141243383.77 rows=6604615 width=8) (actual time=214.078..1322.642 rows=1983210 loops=1)
  Workers Planned: 2
  Workers Launched: 2
  ->  Nested Loop  (cost=0.00..140581922.27 rows=2751923 width=8) (actual time=210.536..1169.303 rows=661070 loops=3)
        Join Filter: (st_intersects(updated_rows.the_geom_local, a.geom) OR (NOT st_touches(updated_rows.the_geom_local, a.geom)))
        ->  Parallel Seq Scan on l_areas a  (cost=0.00..38148.68 rows=275468 width=325) (actual time=210.509..259.184 rows=220357 loops=3)
              Filter: (enable IS TRUE)
        ->  Seq Scan on synthese updated_rows  (cost=0.00..10.10 rows=10 width=36) (actual time=0.000..0.001 rows=3 loops=661070)
Planning Time: 0.971 ms
JIT:
  Functions: 24
  Options: Inlining true, Optimization true, Expressions true, Deforming true
  Timing: Generation 3.580 ms, Inlining 136.693 ms, Optimization 306.181 ms, Emission 187.931 ms, Total 634.385 ms
Execution Time: 1427.601 ms


-- REQUETE st_touches seulement si != Point : 400x plus rapide
explain analyze SELECT
updated_rows.id_synthese AS id_synthese,
a.id_area AS id_area
FROM gn_synthese.synthese as updated_rows
JOIN ref_geo.l_areas a
  ON public.ST_INTERSECTS(updated_rows.the_geom_local, a.geom)  
WHERE a.enable IS TRUE AND (ST_GeometryType(updated_rows.the_geom_local) = 'ST_Point' OR NOT public.ST_TOUCHES(updated_rows.the_geom_local,a.geom));


  Nested Loop  (cost=0.29..35853.75 rows=6605 width=8) (actual time=0.500..3.216 rows=15 loops=1)
  ->  Seq Scan on synthese updated_rows  (cost=0.00..10.10 rows=10 width=36) (actual time=0.005..0.008 rows=3 loops=1)
  ->  Index Scan using index_l_areas_geom on l_areas a  (cost=0.29..3583.70 rows=66 width=325) (actual time=0.282..1.063 rows=5 loops=3)
        Index Cond: (geom && updated_rows.the_geom_local)
        Filter: ((enable IS TRUE) AND st_intersects(updated_rows.the_geom_local, geom) AND ((st_geometrytype(updated_rows.the_geom_local) = 'ST_Point'::text) OR (NOT st_touches(updated_rows.the_geom_local, geom))))
        Rows Removed by Filter: 1
Planning Time: 0.377 ms
Execution Time: 3.273 ms      


